# [2018 Round G](https://codingcompetitions.withgoogle.com/kickstart/round/0000000000051066)

## Product Triplets
给 N 个数字，求出其中满足条件的三元组的数目。  
条件为：其中一个数字等于其他两个数字的乘积。

Large dataset (Test set 2 - Hidden)  
3 ≤ N ≤ 7000.  

### 解答
枚举其中的两个数字（不为 0 或 1），查找乘积是否存在，有几个。  
特判：  
0 * 0 = 0  
0 * x = 0 (x > 0)  
1 * 1 = 1  
1 * x = x (x > 1)  

### Hack 数据
inputs
```cpp
2
6
0 0 0 1 1 1
6
0 0 1 1 2 2
```

outputs
```cpp
Case #1: 11
Case #2: 6
```

***

## Combining Classes
有 N 个班级的成绩，每个班的成绩区间为 [Li, Ri]，(Ri-Li+1) 个学生每人一个不同的分数。现在把所有学生的成绩排序，询问第 K 高的分数的总和。  

**Limits**  
1 ≤ N ≤ 4 × 10^5.  
Li Ri 是由构造函数生成的，最大可能为 10^9  
询问数最多有 10^5 次。  

## 解答
学生的数目非常大，直接统计每个分数的个数太困难。但是每次会给一个区间，这个区间上的所有分数都对应着一个学生。因此可以线段离散化，只记录端点并排序、去重。  
区间处理成左闭右开的区间，即 [Li, Ri + 1)

```cpp
L: 3  2  4  1  7
R: 5  9  9  4 10
After sort & unique: 
score: 1  2  3  4  5  7  9 10
Count from this end point:
count: 1  2  3  3  2  3  1  0
Rank from this end point:
rank: 20 19 17 14 11  7  1  0
```

比如 7 分的对应 3 个人，且分数区间为 [7, 9) 的人数都是 3 个人。因此 7 分的是第 7 名。同时，7 分的也是第 5，6，7 名。

现在查询的名次是 x，需要找到 rank 的区间 [Lrank, Rrank) 使得 x 落在这个区间，再根据这个区间的分数寻找到分数。

由于 rank 数组是非递增的，可以二分查找到 x 所在的区间。

想要利用 `lower_bound` 和 `upper_bound` 找边界怎么办呢？重写
```cpp
rank[i] = all + 1 - rank[i]
```
使得 rank 为非递减，找第 k 高，等价于，第 (all+1-k) 低。普通的数据对拍都过了，不明白为什么 RE，[see line](https://github.com/Baileyswu/NEXT/blob/27f7ab06874c771e085298d97c8cd203c4d9c6f5/EP08/combining.cpp#L102) （严格限定以后 low 就落在 [0, sz) 区间内）。

线性做法：对所有的查询排序，得到查询数组和 rank 数组两个单调数组，即可在线性时间内找到所有 x 对应的区间。

***

## Cave Escape
有一个 N * M 的矩阵地图，给出行走的起点和终点，需要从起点走到终点。  
地图中的陷阱会消耗一些体力（当前体力小于这个体力就不能走入陷阱），也有些格子可以拿药恢复体力，还有一些障碍物不能通行。  
陷阱和药水在经过一次后消失。  
在初始体力 E 的情况下，问可以走到终点吗？若能走到终点，最大体力可以是多少？

**Limits**  
1 ≤ T ≤ 100.  
Time limit: 120 seconds per test set.  
Memory limit: 1 GB.  
1 ≤ N ≤ 100.  
1 ≤ M ≤ 100.  
0 ≤ E ≤ 100000.  
最多 15 个陷阱。  

### 解答

考虑到一条路走了以后还可以回头，陷阱和药水在使用一次以后可以消失，空地上可以走无数次。因此直接去 dfs 或 bfs 从起点到终点的路径会少考虑很多情况。

可以发现，吃掉一个陷阱或药水以后，不管怎么闲逛，得分不变。又陷阱最多 15 个，可以组合出 2^15 种地图，分别表示走不走某个陷阱。每种地图都可以得到从起点出发以后闲逛得到的最高分。若可以抵达终点，则视为一种选择。

每个地图可以认为是一种状态，如果遍历所有的状态，数目有点多。有些状态实际上是不可走的（体力小到不能走入陷阱）。这些状态之间可以相互转移。在转移或不可走的限制下，对状态数进行剪枝。