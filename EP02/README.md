# [2018 Round A](https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050edf)

## Even Digits
求一个数字离最近的吉祥数的距离。  
吉祥数：所有数位上的数字都是偶数。

### 解答
从高到低遍历每个数位，当出现奇数位时，采取 +1 或 -1 的操作。  
找比它小的最大吉祥数，则在这位 -1，后面的数位置为 8.  
找比它大的最小吉祥数，则在这位 +1，后面的数位置为 0.

但是 +1 后有可能出现进位的情况。进位以后高位的数字会由偶数变为奇数，变得不符合条件。因此当发生连锁进位时，每次应该往前 +2，使得高位维持为偶数。也可以认为高位是只能用 0 2 4 6 8 五个符号的五进制数。因此可以将高位的每个数字除2，作为五进制数，进位的时候 +1. 从实际代码实现上看，都需要模拟加法。光是(t/2+1)*2 得到的答案是不对的哟(＾Ｕ＾)ノ~ＹＯ

### Hack 数据
24499 -> 24600  
88893 -> 200000

***

## Lucky Dip
包里有 N 个物品，价值为 Ai，可以等概率抽取物品。任意抽取一个物品的价值期望是多少？好的，是均值。现在给 K 次机会可以重来，参与者尽可能地要提高物品价值，问最后的物品价值的期望是多少？

### 解答

什么是最优策略？

令 E[k] 为给 k 次机会的期望，易得 E[0] = avg(Ai)  

若 k=1，即剩一次重来的机会，拿到 Ai。若 Ai >= E[0]，则不扔了继续持有；若 Ai < E[0]，则扔了，因为下一次的期望就是 E[0]。期望体现着一种平均水平，如果我水平很菜（期望很低）却能抽奖进GG，那我当然进了。  

以此类推，还剩 k 次时考虑，拿了这次以后就剩下 k-1 次了，那么 Ai>= E[k-1]就继续持有，否则宁愿扔了重新抽。

对 N 个物品排好序，通过 E[k-1] 划分扔或不扔，通过 upper_bound 或者 lower_bound 找到分界线（没错，这题两种界答案都一样），确定了抽到其中的 cnt 个物品会扔。其余的 n-cnt 个物品求和为 sum
```cpp
E[k] = (cnt * E[k-1] + sum) /n
```
其中 sum 可以事先处理好。E 也可以滚动起来，不需要开数组（之前误开了 n 的空间就悲惨了）