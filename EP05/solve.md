# 2018 Round D
[2018 Round D](https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050ee1)

## Candies
长为 $N$ 的数组，求其中最大的子序列的和，并满足以下条件：
1. 子序列中最多有 $O$ 个奇数
2. 子序列和 $\leq D$

### 解答
用双指针的移动保证条件 1，给定一个 l 后都找到最远的 r，在这个区间 [l, r] 中找到满足条件 2 的结果。
如数组 {-6 -7 -9 2 4 3 1 -8 -6 -7} 在 O=2 时根据条件 1 可以划分出子序列：
```cpp
-6 -7 -9 2 4
-7 -9 2 4
-9 2 4 3
2 4 3 1 -8 -6
4 3 1 -8 -6
3 1 -8 -6
1 -8 -6 -7
-8 -6 -7
-6 -7
-7
```
在这些序列中找到满足条件 2 的结果。
由于这些序列具有重合的特点，可以重复利用原数组的前缀和来优化。
用 `multiset` 存储序列的前缀和 `sum[r]`，由于条件 2 为 `sum[r]-sum[l-1]<=D`，因此需要在 `multiset` 里找到最大的`sum[r]` 满足 `sum[r]<=sum[l-1]+D`.


### 补充知识点
```cpp
x = lower_bound(a) x 是第一个大于等于 a 的数的地址
x = upper_bound(a) x 是第一个大于 a 的数的地址
```

左闭右开
```cpp
x = lower_bound(a)
y = upper_bound(b)
[x, y) 区间中的所有数值域为 [a,b)

e.g.
{10 20 30 40 50 60 70}
x = lower_bound(30)
y = upper_bound(40)
[x, y) = [2, 4) = {30, 40}
```

本题需要的是第一个小于等于 a 的数，因此需要先找到第一个大于等于 a+1 的数，再往前找一个。

### Hack 数据
inputs
```cpp
2
2 0 1000000000000000
1 1 1 1 0 100 0
5 0 1000000000000000
1 1 1 1 0 100 0
```
outputs
```
Case #1: IMPOSSIBLE
Case #2: 2
```
