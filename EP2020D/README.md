# [2020 Round D](https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ff08)

## Record Breaker
给定长为 N 的数列，求其中满足条件的数字有几个：  
1. 该数比前面所有的数字大
2. 该数比后面相邻的数字大

### 解答
扫一遍。保留前面最大的数字。

***

## Alien Piano
用四个音符模拟复杂的曲子。若原曲中本音符高于前一个音，则模拟音符也要让本音高于前音。低于、等于同理。当超过四个音则要中断，重新表示。问模拟的过程中最少中断几次。

### DP 解法

开 dp[N][4] 大小的数组。  
`dp[i][j]`: 第 i 个音为 j 这个音符时会中断的次数。

不考虑连贯性，则有 `dp[i][j] = min(dp[i-1][k] + 1) for k in range(4)`  
若考虑连贯性，则有
1. 高于前面的音 `dp[i][j] = min(dp[i-1][k]) for j > k`
2. 低于前面的音 `dp[i][j] = min(dp[i-1][k]) for j < k`
3. 等于前面的音 `dp[i][j] = min(dp[i-1][k]) for j < k`

### 贪心解法

有连续上升或下降 len 长度的音符时，需要中断 `(len-1)//4` 次。

***

## Beauty of tree
给定一棵树，随机访问其中的一个节点，并朝根节点走。甲每隔 A 步涂色，乙每隔 B 步涂色，涂色的编号为树的美丽值。问美丽值的期望。

### 解答
计算出每个节点会被几个儿子访问到。对于同一个节点 i，若甲有 p 个儿子可访问到，乙有 q 个儿子可访问到，则该点对美丽值的期望的贡献为 `i*(1-(p/n)*(1-q/n))`. 将所有贡献加起来即是总的期望。

怎么计算每个节点会被几个儿子访问到，记这个值为 `son[i]` ？在 DFS 的过程中，若访问到节点 i，会有一个从根节点到 i 的 path。在 path 上很容易找到 i 前面跨 A 步的节点 j。则可以把 i 当前的 `son[i]` 加到 `son[j]` 上。DFS 一遍以后可以求出所有的 son.

***

## Locked Doors
有 N 个房间，N-1 扇门，每两个房间中间隔着一扇门。撞开一扇门要花 di 个力气。现在从某个房间进去，每次都选力气小的门撞开，会有个房间的访问序列。询问 Q 次，从 Si 房间开始访问到的第 Ki 个房间是几号房间。

### 错误示范
用并查集记录每个房间左边和右边的房间分别是几号。赛后我突然觉得这个思路真的没必要并查集啊(ˉ▽ˉ；)...这是个一维的维护左右边界就够了用什么并查集。2019 Round C Wiggle Walk 后遗症。

### 笛卡尔树
假设先撞开了门 i，找到左边最近的力气大于 di 的门 `left[i]`, 和右边最近的力气大于 di 的门 `right[i]`，则会先撞开左门到右门区间的所有门，再选择两者小的那扇撞开。以小的那扇门的 id 作为 i 的父亲结点。且 i 在父亲左边则是左儿子，在右边则是右儿子。这样可以组成一棵[笛卡尔树](https://www.geeksforgeeks.org/cartesian-tree/)。


```cpp

         30
        /  \
       9    8
      /    /
     6    7
      \    \
       5    1
      /
     4
    /
   2

id     1  2  3  4  5  6  7  8  9
door   6  2  4  5  9 30  7  1  8
================================
left   0  1  1  1  0  0  6  7  6
right  5  3  4  5  6 10  9  9 10
================================
parent 5  3  4  1  6  6  9  7  6
lchild 0  0  2  3  1  5  0  0  7
rchild 4  0  0  0  0  9  8  0  0
```

容易得到笛卡尔树有这样的性质：  
1. 父节点的值比两个子节点大
2. 结点的左子树在原序列的左边，右子树的原序列的右边
3. 中序遍历即是原来的序列

因此在撞门的遍历中，必定先遍历完他所在的子树再往上遍历。

遍历顺序为：自己 -> 左或右子树 -> 父亲 -> 父亲的左或右子树 -> ……

容易得到的问题是：当有两个未遍历的子树时，应该先遍历哪个？

答案是并不会出现这样的情况。首先在选择起点的时候，其实是选择了第一个房间的两扇门中力气较小的一扇。也就是他必须比相邻的数字要小。而拥有两个子树的结点不可能比相邻的数字小。而在后面的遍历中，父亲总是由一侧子树上去，因此最多有一个未遍历的子树。

因此，子树的大小可以先进行预处理，在遍历时可以直接加上这个大小表示经过。
