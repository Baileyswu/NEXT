# [2019 Round C](https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050ff2)

## Wiggle Walk
一个机器人可以按照指令往东南西北四个方向走。如果遇到已经走过的点，则沿着该方向继续走，直到走到一个没有走到过的点。已知起点和方向指令，求终点。

Test set 2 (Hidden)  
Time limit: 60 seconds.  
1 ≤ N ≤ 5 × 10^4.  

### 解答
要越过给定方向的连续的点，用并查集的思想，将寻找的过程压缩。如：A 的东边的东边的点，是 A 的东边的点。只需要将最东边的点存储下来即可。可以将点映射到 id 的集合。点到点的映射转化为 id 到 id 的映射，即数组可以完成。

***

## Circuit Board
给一个矩阵，要求找到一个最大的子矩阵，满足每行的最大值和最小值之差不超过 K。

**Limits**  
1 ≤ T ≤ 50.  
1 ≤ R ≤ 300.  
1 ≤ C ≤ 300.  
0 ≤ Vi, j ≤ 10^3 for all i, j.  

### 解答
预处理好从 a[i][j] 为起始位置到 a[i][k] 为止的子序列中的最大值和最小值的差值。  
暴力枚举面积最大值。

***

## Catch Some

有 N 条狗在不同位置 Pi (Pi > 0) ，分别有自己的颜色 Ai。从原点 O 出发，若身穿和狗相同颜色的衣服则可以看到狗。若想看到其他颜色的狗则需再回家换衣服，重新出发。问看到 K 条狗最少需要走多少路？

**Limits**  
1 ≤ T ≤ 100.  
1 ≤ N ≤ 1000.  
1 ≤ K ≤ N.  
1 ≤ Ai ≤ 1000.  
1 ≤ Pi ≤ 10^5.  

### 解答

每种颜色的狗相互独立。最后一种颜色的狗距离不用 *2，其他需要绕回来穿衣服距离 *2.

`dp[i][j][z]`：前 i 种颜色的狗中，看见 j 条狗。z = 0 时全部均有折返；z = 1时，存在一次未折返。

结果为：`dp[1000][K][1]`
```cpp
dp[i][j][0] = min( dp[i-1][j][0], dp[i-1][j-k][0] + 2 * dis[i][k] for all k)
dp[i][j][1] = min( dp[i-1][j][1], dp[i-1][j-k][1] + 2 * dis[i][k] for all k)
dp[i][j][1] = min( dp[i-1][j][1], dp[i-1][j-k][0] + dis[i][k] for all k)
```