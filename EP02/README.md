# [2018 Round A](https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050edf)

## Even Digits
求一个数字离最近的吉祥数的距离。  
吉祥数：所有数位上的数字都是偶数。

### 解答
从高到低遍历每个数位，当出现奇数位时，采取 +1 或 -1 的操作。  
找比它小的最大吉祥数，则在这位 -1，后面的数位置为 8.  
找比它大的最小吉祥数，则在这位 +1，后面的数位置为 0.

但是 +1 后有可能出现进位的情况。进位以后高位的数字会由偶数变为奇数，变得不符合条件。因此当发生连锁进位时，每次应该往前 +2，使得高位维持为偶数。也可以认为高位是只能用 0 2 4 6 8 五个符号的五进制数。因此可以将高位的每个数字除2，作为五进制数，进位的时候 +1. 从实际代码实现上看，都需要模拟加法。光是 (t/2+1)*2 得到的答案是不对的哟(＾Ｕ＾)ノ~ＹＯ

### Hack 数据
24499 -> 24600  
88893 -> 200000

事实证明这种有 8 需要进位的情况写挂了也影响不大（之前写错了也还是 AC 了）。因为一般来说答案是往比它小的方向去找。

***

## Lucky Dip
包里有 N 个物品，价值为 Ai，可以等概率抽取物品。任意抽取一个物品的价值期望是多少？好的，是均值。现在给 K 次机会可以重来，参与者尽可能地要提高物品价值，问最后的物品价值的期望是多少？

### 解答

什么是最优策略？

令 E[k] 为给 k 次机会的期望，易得 E[0] = avg(Ai)  

若 k=1，即剩一次重来的机会，拿到 Ai。若 Ai >= E[0]，则不扔了继续持有；若 Ai < E[0]，则扔了，因为下一次的期望就是 E[0]。期望体现着一种平均水平，如果我水平很菜（期望很低）却能抽奖进GG，那我当然进了。  

以此类推，还剩 k 次时考虑，拿了这次以后就剩下 k-1 次了，那么 Ai>= E[k-1]就继续持有，否则宁愿扔了重新抽。

对 N 个物品排好序，通过 E[k-1] 划分扔或不扔，通过 upper_bound 或者 lower_bound 找到分界线（没错，这题两种界答案都一样），确定了抽到其中的 cnt 个物品会扔。其余的 n-cnt 个物品求和为 sum
```cpp
E[k] = (cnt * E[k-1] + sum) /n
```
其中 sum 可以事先处理好。E 也可以滚动起来，不需要开数组（之前误开了 n 的空间就悲惨了）

***

## Scrambled Words
给一个字典，统计里面有多少个词以及变体出现在给定的字符串中。  
变体：首尾字母一样，中间字符打乱。如 this 变体为 tihs。

L 是字典大小，N 是字符串长度.  
词的总长不超过 10^5.

* Small dataset (Test set 1 - Visible)  
Time limit: 20 seconds.  
1 ≤ L ≤ 1000.  
2 ≤ N ≤ 1000.  

* Large dataset (Test set 2 - Hidden)  
Time limit: 150 seconds.  
1 ≤ L ≤ 20000.  
2 ≤ N ≤ 10^6.

### 小数据做法
每个词可以统计出 26 个字母的出现频数。在字符串上滑动窗口，改变频数。  

### 大数据做法
基于滑动窗口进行优化。

优化一：Hash  
将字符串的首位字母，字母的频数，进行 hash 编码。
编码设置为 `unsigned long long` 若溢出则会进行循环表示。

优化二：同样长度的词在匹配时合并在一起进行窗口滑动。  
最坏情况下每个长度的词仅有一个，则由于词的总长限制，词的个数数量级在 O(sqrt(10^5))。  
总的复杂度为 O(N sqrt(10^5))